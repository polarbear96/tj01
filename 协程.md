##                                                协程 



## 关于迭代器

```python
import time
from collections.abc import Iterable
from collections.abc import Iterator


class Classmate(object):
    def __init__(self):
        self.names = list()

    def add(self, name):
        self.names.append(name)

    def __iter__(self):
        """如果想要一个对象称为一个　可以迭代的对象，即可以使用for，那么必须实现__iter__方法"""
        return ClassIterator(self)    # [1] 

class ClassIterator(object):

    def __init__(self, obj):
        self.obj = obj    # [2] 
        self.current_num = 0

    def __iter__(self):
        pass

    def __next__(self):
        if self.current_num < len(self.obj.names):
            ret = self.obj.names[self.current_num]   # [3]
            self.current_num += 1
            return ret
        else:
            raise StopIteration

classmate = Classmate()
classmate.add("老王")
classmate.add("王二")
classmate.add("张三")

for name in classmate:
    print(name)
    time.sleep(1)
```

​       [1]处return ClassIterator(self)其实就像类似于返回一个已传参的函数，这里是返回一个已传参的类(即返回一个实例对象)，参数就是Classmate的实例对象(此代码中即为classmate), [2]处和[3]处实现了在 ClassIterator中获取Classmate中的属性值   



​      其实可以将两个类合成一个类，在一个类中就可以实现迭代器：(return self,以自己为返回的实例对象，而自己又同时具有\_\_init\_\_()和\_\_next\_\_()方法，是一个迭代器，allright ，逻辑自洽)

```python
import time
from collections.abc import Iterable     
from collections.abc import Iterator


class Classmate(object):
    def __init__(self):
        self.names = list()
        self.current_num = 0

    def add(self, name):
        self.names.append(name)

    def __iter__(self):
        """如果想要一个对象称为一个　可以迭代的对象，即可以使用for，那么必须实现__iter__方法"""
        return self  # 调用iter(xxobj)的时候 只要__iter__方法返回一个 迭代器即可，至于是自己 还是 别的对象都可以的, 但是要保证是一个迭代器(即实现了 __iter__  __next__方法)

    def __next__(self):
        if self.current_num < len(self.names):
            ret = self.names[self.current_num]
            self.current_num += 1
            return ret
        else:
            raise StopIteration


classmate = Classmate()
classmate.add("老王")
classmate.add("王二")
classmate.add("张三")

# print("判断classmate是否是可以迭代的对象:", isinstance(classmate, Iterable))
# classmate_iterator = iter(classmate)
# print("判断classmate_iterator是否是迭代器:", isinstance(classmate_iterator, Iterator))
# print(next(classmate_iterator))

for name in classmate:
    print(name)
    time.sleep(1)

    #运行结果是依次输出 老王 王二 张三
```



>  上述代码有几点要注意，for name in classmate会触发classmate的\_\_iter\_\_()方法(并且此方法需要一个迭代器作为返回值)，接着将此方法所返回的迭代器中的\_\_next\_\_()方法的返回值传给name, 此步骤会一直进行不会中断，当未接收到返回值时name取值显然未null, 但并不会中断，这里的 raise StopIteration就是为了让其中段  ；至于这里的if条件判断，若没有此条件很快self.current_num将超出列表的长度而引发错误     ==此外：== 

```python
class Hi(object):
    def __init__(self):
        self.age = 1

    def addone(self):
        self.age = 2
        
tom = Hi()
tom.addone()
print(tom.age)
#  这里将打印出2   因为实例方法中对实例变量值的修改不会随着函数调用结束而恢复
```

所以这里self.current_num的累加才能实现     这里若将`self.names = list()` `self.current_num = 0` 放在\_\_next\_\_()函数内部那么每次都初始话一次当然也不行



斐波拉契数列：

```python
class Fibonacci(object):
    def __init__(self, all_num):
        self.all_num = all_num
        self.current_num = 0
        self.a = 0
        self.b = 1

    def __iter__(self):
        return self

    def __next__(self):
        if self.current_num < self.all_num:
            ret = self.a
        
            self.a, self.b = self.b, self.a+self.b
            self.current_num += 1

            return ret
        else:
            raise StopIteration


fibo = Fibonacci(10)


for num in fibo:
    print(num)


```

> 没啥说的



**plus :回到开头， 什么是迭代器：[1, 2, 3, 4, 5, 6] 数组并不是迭代器，但是我们可以通过iter方法将其迭代器取出来：** 

```python
a = [1,2,3,4,5]
print(iter(a))

输出：
<list_iterator object at 0x03519D90>   # 这便是此数组中的迭代器
#   由于万物皆是类，list也不例外，只是python将其封装了起来而已，我们通过iter函数取出其迭代器(iter函数相当于执行了obj.__iter__())
```



plus ：并不是只有for循环能接受可迭代对象、list、tuple也能接收, e.g. list(range(10))这种并不是简单的格式转换，而是遍历了这个可迭代对象



## 生成器

```python
def create_num(all_num):
    print("----1---")
    # a = 0
    # b = 1
    a, b = 0, 1
    current_num = 0
    while current_num < all_num:
        print("----2---")
        # print(a)
        yield a  # 如果一个函数中有yield语句，那么这个就不在是函数，而是一个生成器的模板
        print("----3---")
        a, b = b, a+b
        current_num += 1
        print("----4---")

# 如果在调用create_num的时候，发现这个函数中有yield那么此时，不是调用函数，而是创建一个生成器对象
obj = create_num(10)   #[0] 
 
ret = next(obj)    # [1]
print(ret)         # [2]

ret = next(obj)   # [3]
print(ret)        # [4]

obj2 = create_num(2)  #[5]

ret = next(obj2)   #[6]
print(ret)

# for num in obj:
#    print(num)
# [0]处 只是相当于创建一个生成器对象，并没有触发函数的执行
# [1]处 next会自动调用__next__()方法，触发整个函数的执行 输出 ----1---  ----2--- 之后将yield的值赋
# 给ret  之后函数停止运行  除非有下一个next方法，才能触发函数之后的行为
# [2]处 打印出ret的值 
# [3]处 再次被触发函数，从上次停止的地方开始执行，打印出 ----4--- ----2---  之后将yield的值赋给ret
# 之后函数停止运行  除非有下一个next方法，才能触发函数之后的行为
# [4]处 打印出ret的值
# [5]处 创建另一个生成器对象，同样不会触发函数的执行
# [6]处 next触发函数执行，但是这是一个新对象，所以并不从刚才停止的地方开始执行而是重新开始，输出---#-1---  ----2--- 之后将yield的值赋给ret  之后函数停止运行  除非有下一个next方法，才能触发函数之后的#行为
```

==生成器是一种特殊的迭代器，虽然它没有\_\_iter\_\_()方法和\_\_next\_\_()方法，知道即可==   

生成器中的返回值

```python
def create_num(all_num):
    # a = 0
    # b = 1
    a, b = 0, 1
    current_num = 0
    while current_num < all_num:
        # print(a)
        yield a  # 如果一个函数中有yield语句，那么这个就不在是函数，而是一个生成器的模板
        a, b = b, a+b
        current_num += 1
    return "ok...."      
#如果这里的return语句写在while的代码块内，那么生成器显然就废了，函数接收到返回值后直接over了
#这个return的返回值不好取，需要计算什么时候while条件不再满足
obj2 = create_num(50)

while True:
    try:
        ret = next(obj2)
        print(ret)
    except Exception as ret:
        print(ret.value)
        break
# 像这样写可以解决，比较通用的写法

```





**生成器&send方式**  

```python
def create_num(all_num):
    a, b = 0, 1
    current_num = 0
    while current_num < all_num:
        ret = yield a
        print(">>>ret>>>>", ret)
        a, b = b, a+b
        current_num += 1

obj = create_num(10)

# obj.send(None)  # send一般不会放到第一次启动生成器，如果非要这样做 那么传递None

ret = next(obj)
print(ret)

# send里面的数据会 传递给第5行，当做yield a的结果，然后ret保存这个结果
# 传参之后，同样的，a 会赋值给ret. 
ret = obj.send("hahahha")  
print(ret)

#  了解一下即可
```



==生成器最大的特点就是保证一个函数只执行一部分而返回一个值==



## 使用生成器实现多任务

```python
import time


def task_1():
    while True:
        print("---1----")
        time.sleep(0.1)
        yield


def task_2():
    while True:
        print("---2----")
        time.sleep(0.1)
        yield


def main():
    t1 = task_1()
    t2 = task_2()
    # 先让t1运行一会，当t1中遇到yield的时候，再返回到24行，然后
    # 执行t2，当它遇到yield的时候，再次切换到t1中
    # 这样t1/t2/t1/t2的交替运行，最终实现了多任务....协程
    while True:       #  [1]
        next(t1)
        next(t2)
        
if __name__ == "__main__":
    main()

```

 这样便实现了“多任务”，可见这里核心的其实就是yield将task_1和task_1函数都切成了很多段，之后[1]处的`while True`让函数每此执行一小段.  ==其核心其实是把函数本身“切断了”== 

 

**greenlet gevent完成多任务** 

greenlet略(不够好，用到很少)

```python
import gevent
import time
# from gevent import monkey  # [1]
# monkey.patch_all()         # [2]


def f1(n):
    for i in range(n):
        print(gevent.getcurrent(), i)
        # time.sleep(0.5) # [3]
        gevent.sleep(0.5)

def f2(n):
    for i in range(n):
        print(gevent.getcurrent(), i)
        # time.sleep(0.5) # [4]
        gevent.sleep(0.5)

def f3(n):
    for i in range(n):
        print(gevent.getcurrent(), i)
        # time.sleep(0.5) [5]
        gevent.sleep(0.5)

print("----1---")
g1 = gevent.spawn(f1, 5) # 5作为实参传递给f1中的n     这里只是建了一个对象，不会运行
print("----2---")
g2 = gevent.spawn(f2, 5)
print("----3---")
g3 = gevent.spawn(f3, 5)
print("----4---")
g1.join()
g2.join()
g3.join()

```

==线程结束协程死   协程依赖于线程 线程依赖于进程     进程切换用到的资源最大 协程最小==

==耗时操作如input recv connect accept等都需要改成gevent中的才行 ,手动改较麻烦，可以通过引入[1], [2]处的代码来打补丁，之后用[3]、[4]、[5]处的代码代替gevent中的耗时操作，因为[1]+[2]处的代码可以全局替换耗时操作为gevent中的操作==    

```python
gevent.joinall([g1, g2, g3])       # 可以代替上面的三个join()函数，实际写代码就用joinall.
```



协程下载图片案例:

```python
import urllib.request       # [0] 引入此模块后，python可以处于互联网环境
import gevent
from gevent import monkey

monkey.patch_all()


def downloader(img_name, img_url):
	req = urllib.request.urlopen(img_url)

	img_content = req.read()   # 将图片信息读入img_content

	with open(img_name, "wb") as f:
		f.write(img_content)   # 将图片写入名为img_name   相当于下载了网上的图片

def main():
	gevent.joinall([
	        gevent.spawn(downloader, "3.jpg", "https://rpic.douyucdn.cn/appCovers/2017/09/22/1760931_20170922133718_big.jpg"), # [1]
	        gevent.spawn(downloader, "4.jpg", "https://rpic.douyucdn.cn/appCovers/2017/09/17/2308890_20170917232900_big.jpg")  # [2]
	])


if __name__ == '__main__':
	main()
    
# 引入此模块后网络上的图片便可以通过诸如 [1]、[2]处的图片地址访问到

```



##### 实际中用到的协程就是调用gevent来完成，此文提到的其他方法只供了解  



----

> 多任务中的多进程和多线程位于word文档中，未转为markdown格式，无此必要. 

