#                                         web服务器[^ 1]



## 01-正则表达式



==正则表达式的核心部分是通用的，只是在不同语言中的相应函数名可能不同==



**匹配单个字符**

```python
.    # 匹配任意一个字符   (唯独无法匹配\n，即无法匹配换行符）
[]   # 匹配[]中列举的字符
\d   # 匹配数字,即0-9
\D   # 匹配非数字，即不是数字
\s   # 匹配空白，即空格和tab键
\S   # 匹配非空白
\w   # 匹配单词字符，即a-z,A-Z,0-9，_   以及各种语言如汉字  范围很广
\W   # 匹配非单词字符



re.match(r"[12345678]",...)
# 这里可以匹配1-8之间的任意一个数字
re.match(r"[1-8]",...)
# 匹配1-8之间任意一个数字
re.match(r"[1-36-8]",...)
# 匹配1-3，6-8之间任意一个数字(1,2,3,6,7,8)
re.match(r"[A-Za-z1-5]"...) 
# 注意  ：这里A-Z只能匹配大写，a-z是小写       而 \w既可以匹配大写也可以匹配小写
re.match(r".*", "\n").group()
#  此时不匹配，上面已经提到过了，"."无法匹配\n   
re.match(r".*", "\n", re.S).group()
#  加上re.S这个参数就可以真正匹配到任意一个字符.

```



**匹配多个字符** 

```python
*  # 匹配前一个字符出现0次或者无限次，即可有可无
+  # 匹配前一个字符出现1次或者无限次，即至少有一次
？ # 匹配前一个字符出现0次或者1次    
{m} # 匹配前一个字符出现m次
{m,n} # 匹配前一个字符出现从m到n次

 
 re.match(r"速度与激情\d{3}", "速度与激情1").group()
# \d(数字)需要出现三次并且只能出现三次
 re.match(r"速度与激情\d{1,3}", "速度与激情12").group()
# \d(数字)可以出现1-3次，即1次、2次、3次
re.match(r"021-?\d{8}", "02112345678").group()
re.match(r"021-?\d{8}", "021-12345678").group()
# 显然二者都可以匹配，"-"可以有1个或者0个

```



**匹配开头和结尾**

```python
^  # 匹配字符串开头     (match默认从开头开始匹配)
$  # 匹配字符串结尾     
```



demo（判断字符串是否符合命名规范）：

```python
import re


def main():
	names = ["age", "_age", "1age", "age1", "a_age", "age_1_", "age!", "a#123", "__________"]
	for name in names:
		ret = re.match(r"^[a-zA-Z_][a-zA-Z0-9_]*$", name)   # [1]
		if ret:
			print("变量名:%s 符合要求....通过正则匹配出来的数据是:%s" % (name, ret.group()))
		else:
			print("变量名:%s 不符合要求...." % name)


if __name__ == "__main__":
	main()
    
# [1]处不能写r"^[a-zA-Z_][\w]*$",因为\w范围过广.
# if ret:  ...   else这种写法很简便，了解一下. 若正则匹配，则返回一个对象，if obj会返回True.
```

- 若在正则表达式中仅仅遇到了一些普通的字符，比如 .  比如 ? 等，仅仅需要在它们前面添加一个反斜杠进行转义(e.g. `re.match(r"[a-zA-Z_0-9]{4,20}\.com$")`,这里需要在.之前加\\)



- 分组

```python
| # 匹配左右任意一个表达式，相当于or
(ab) # 将括号中字符作为一个分组
\num # 引用分组num匹配到的字符串
(?P<name>)  # 分组起别名       了解一下即可
(?P=name)  # 分组起别名为name分组匹配到的字符串   了解一下即可
```

```python
re.match(r"[a-zA-Z_0-9]{4,20}@(163|126)\.com$", email)
#  "|"的作用范围会自动到括号，即163或者126二选一

re.match(r"<(\w*)>.*</\1>",...) 
#  这里的\1是指此处需要和group(1)的内容完全相同  
#  注意\1处没括号
```

- re.search()和match的区别就是它不会从头匹配，但是也仍然只匹配一个，匹配所有满足条件的组分需要写re.findall(), 它将结果以列表的形式返回：`re.findall(r"\d+","python = 9999, c = 7898, c++ = 1234")` 

​       返回`["9999","7898","1234"]` 

- sub自行百度，略.

## 简单web服务器实现

```python
import socket
import re


def service_client(new_socket):
    """为这个客户端返回数据"""

    # 1. 接收浏览器发送过来的请求 ，即http请求  
   
    request = new_socket.recv(1024).decode("utf-8")   # [1] 注意要对request解码
    # print(">>>"*50)                                           
    # print(request)                                

    request_lines = request.splitlines()  # [2]splitlines可以根据换行符对字符换进行切割，切成列表
    print("")
    print(">"*20)
    print(request_lines)

    # GET /index.html HTTP/1.1    [3], request_lines[0]就是这种形式，之后[4]处用正则去匹配它
    # get post put del        实际的请求可能有很多种而不仅仅是get方式
    file_name = ""
    #[4] []内的^表示非，这里意为非/字符，非空格字符  以下正则会匹配 GET /index.html
    ret = re.match(r"[^/]+(/[^ ]*)", request_lines[0])
    if ret:
        file_name = ret.group(1)           #[5] 将/index.html取出来
        # print("*"*50, file_name)
        if file_name == "/":
            file_name = "/index.html"


    # 2.  返回http格式的数据，给浏览器
    
    try:
        f = open("./html" + file_name, "rb")   #[6]直接读为二进制省去了编码的过程
    except:
        response = "HTTP/1.1 404 NOT FOUND\r\n"
        response += "\r\n"
        response += "------file not found-----"
        new_socket.send(response.encode("utf-8"))
    else:
        html_content = f.read()
        f.close()
        # 2.1 准备发送给浏览器的数据---header
        response = "HTTP/1.1 200 OK\r\n"
        response += "\r\n"
        # 2.2 准备发送给浏览器的数据---body

        # 将response header发送给浏览器
        new_socket.send(response.encode("utf-8"))  
        #[7] 由于body是用rb读取的，所以这里head需要编码而body不需要，因此将二者分开发送，
        #若body用r读入显然这里可以head+body后一次性编码发送.
        # 将response body发送给浏览器
        new_socket.send(html_content)


    # 关闭套接
    new_socket.close()
    

def main():
    """用来完成整体的控制"""
    # 1. 创建套接字
    tcp_server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    #[8] 设置当服务器先close 即服务器端4次挥手之后资源能够立即释放，这样就保证了下次运行程序时可以立即使用之前的端口：
    tcp_server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    

    # 2. 绑定
    tcp_server_socket.bind(("", 7890))

    # 3. 变为监听套接字
    tcp_server_socket.listen(128)

    while True:
        # 4. 等待新客户端的链接
        new_socket, client_addr = tcp_server_socket.accept()

        # 5. 为这个客户端服务
        service_client(new_socket)

    # 关闭监听套接字
    tcp_server_socket.close()


if __name__ == "__main__":
    main()

# 请求一个html页面时，遇到了html文档中如css链接或页面中链接图片的超链接等，浏览器会再次发送请
# 求以获取其信息，以上的实例中浏览器一共发送了5次信息
# 将[1]处的request信息(浏览器的请求信息)解码后，用splitlines切割(根据换行符切割字符串为list)将
# 为列表，其第一个元素为'GET  /index.thml.....' 
# 些列信息，

# 服务器的服务套接字关闭浏览器才会刷新出页面.
```



## 并发服务器实现

**多进程实现http服务器** 

```python
import socket
import re
import multiprocessing


def service_client(new_socket):
    """为这个客户端返回数据"""

    # 1. 接收浏览器发送过来的请求 ，即http请求  
    # GET / HTTP/1.1
    # .....
    request = new_socket.recv(1024).decode("utf-8")
    # print(">>>"*50)
    # print(request)

    request_lines = request.splitlines()
    print("")
    print(">"*20)
    print(request_lines)

    # GET /index.html HTTP/1.1
    # get post put del
    file_name = ""
    ret = re.match(r"[^/]+(/[^ ]*)", request_lines[0])
    if ret:
        file_name = ret.group(1)
        # print("*"*50, file_name)
        if file_name == "/":
            file_name = "/index.html"




    # 2. 返回http格式的数据，给浏览器
    
    try:
        f = open("./html" + file_name, "rb")
    except:
        response = "HTTP/1.1 404 NOT FOUND\r\n"
        response += "\r\n"
        response += "------file not found-----"
        new_socket.send(response.encode("utf-8"))
    else:
        html_content = f.read()
        f.close()
        # 2.1 准备发送给浏览器的数据---header
        response = "HTTP/1.1 200 OK\r\n"
        response += "\r\n"
        # 2.2 准备发送给浏览器的数据---boy
        # response += "hahahhah"

        # 将response header发送给浏览器
        new_socket.send(response.encode("utf-8"))
        # 将response body发送给浏览器
        new_socket.send(html_content)


    # 关闭套接
    new_socket.close()
    

def main():
    """用来完成整体的控制"""
    # 1. 创建套接字
    tcp_server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    tcp_server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)

    # 2. 绑定
    tcp_server_socket.bind(("", 7890))

    # 3. 变为监听套接字
    tcp_server_socket.listen(128)

    while True:
        # 4. 等待新客户端的链接
        new_socket, client_addr = tcp_server_socket.accept()

        # 5. 为这个客户端服务
        p = multiprocessing.Process(target=service_client, args=(new_socket,))
        p.start()

        new_socket.close()     # [1]


    # 关闭监听套接字
    tcp_server_socket.close()


if __name__ == "__main__":
    main()


    # 这里最核心的地方就在于[1]处需要在主进程中关闭套接字，因为多进程不共享全局变量，这里子进程关闭close后主进程中的套接字并不受影响，所以导致套接字在两个进程中一开一关。然而，这两个套接字的指向都是操作系统底层的某个文件，只有当他们都调用close时底层文件才会真正关闭，所以这里需要手动关闭主进程中的套接字，让子进程自由发挥.
    # 了解一下 三次握手的开始是客户但发送connect  成功是服务器调用accept
    
    
```

​    **多线程实现http服务器和多进程的差别在于上述[1]处不可以关闭套接字，否则子线程刚刚创建就从主线程中关闭套接字导致子线程的套接字也废了，导致服务器无法服务**  



**协程实现http服务器** 

```python
import socket
import re
import gevent                    # [1]
from gevent import monkey        # [2]

monkey.patch_all()               # [3]

def service_client(new_socket):
    """为这个客户端返回数据"""

    # 1. 接收浏览器发送过来的请求 ，即http请求  
    # GET / HTTP/1.1
    # .....
    request = new_socket.recv(1024).decode("utf-8")
    # print(">>>"*50)
    # print(request)

    request_lines = request.splitlines()
    print("")
    print(">"*20)
    print(request_lines)

    # GET /index.html HTTP/1.1
    # get post put del
    file_name = ""
    ret = re.match(r"[^/]+(/[^ ]*)", request_lines[0])
    if ret:
        file_name = ret.group(1)
        # print("*"*50, file_name)
        if file_name == "/":
            file_name = "/index.html"

    # 2. 返回http格式的数据，给浏览器
    
    try:
        f = open("./html" + file_name, "rb")
    except:
        response = "HTTP/1.1 404 NOT FOUND\r\n"
        response += "\r\n"
        response += "------file not found-----"
        new_socket.send(response.encode("utf-8"))
    else:
        html_content = f.read()
        f.close()
        # 2.1 准备发送给浏览器的数据---header
        response = "HTTP/1.1 200 OK\r\n"
        response += "\r\n"
        # 2.2 准备发送给浏览器的数据---boy
        # response += "hahahhah"

        # 将response header发送给浏览器
        new_socket.send(response.encode("utf-8"))
        # 将response body发送给浏览器
        new_socket.send(html_content)


    # 关闭套接
    new_socket.close()
   
def main():
    """用来完成整体的控制"""
    # 1. 创建套接字
    tcp_server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    tcp_server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)

    # 2. 绑定
    tcp_server_socket.bind(("", 7890))

    # 3. 变为监听套接字
    tcp_server_socket.listen(128)

    while True:
        # 4. 等待新客户端的链接
        new_socket, client_addr = tcp_server_socket.accept()

        # 5. 为这个客户端服务
        gevent.spawn(service_client, new_socket)     # [4]

        # new_socket.close()

    # 关闭监听套接字
    tcp_server_socket.close()

if __name__ == "__main__":
    main()

# 协程实现http服务器相对于线程只是将[1] [2] [3] [4]处改成协程的写法
# 注意[4]处gevent的spawn的括号内没有target和args, 	也没有tuple, 参数是直接传入的
# 通常协程的效率是最高的
```



**单进程、线程、非堵塞实现并发原理**

```python
import socket
import time

tcp_server_tcp = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
tcp_server_tcp.bind(("", 7899))
tcp_server_tcp.listen(128)
tcp_server_tcp.setblocking(False)  # [1] 设置套接字为非堵塞的方式

client_socket_list = list()

while True:

    try:
        new_socket, new_addr = tcp_server_tcp.accept()   # [2]
    except Exception as ret:
        print("---没有新的客户端到来---")
    else:
        print("---只要没有产生异常，那么也就意味着 来了一个新的客户端----")
        new_socket.setblocking(False)  # 设置套接字为非堵塞的方式   [3]
        client_socket_list.append(new_socket)
        
    for client_socket in client_socket_list:
        try:
            recv_data = client_socket.recv(1024)      # [4]
        except Exception as ret:
            print(ret)
            print("----这个客户端没有发送过来数据----")
        else:
            print("-----没有异常-----")
            print(recv_data)
            if recv_data:
                # 对方发送过来数据
                print("----客户端发送过来了数据-----")
            else:
                # 对方调用close 导致了 recv返回
                client_socket.close()
                client_socket_list.remove(client_socket)
                print("---客户端已经关闭----")
        
# 套接字的所有方法如send connect bind recv等都是默认堵塞的，可以如[1]处所示将其设置为非堵塞.
# 设置套接字为非堵塞并不是一劳永逸的，每个套接字需要分别设置，如[3]处也有一个.
# 设置套接字为非阻塞之后，程序运行到此处而堵塞没有被解开就会引发错误.如[2]处没有客户端连接，[4]处没有
# 接收到数据都会引发错误(plus：客户端调用close显然堵塞会被解开，所以不会引发错误但会接收到null)

```

> 桥接？???NAT??



**长连接与短链接** ：

​         **通过同一个套接字获取多个数据是长链接，每获取一个数据都需要三次握手和四次挥手的是短链接**

**之前的http服务器案例虽然头文件中写了1.1版本但整个代码的效果显然是短链接**

**短：建立连接-- 数据传输 --关闭连接 ..建立连接-- 数据传输 --关闭连接           (http 1.0 version)**

**长： 建立连接-- 数据传输 ..（保持连接）..数据传输 --关闭连接               (http 1.1  varsion)**   (==10'40'' photo==)



 **单进程、线程、非堵塞、长链接的http服务器**

```python
import socket
import re

def service_client(new_socket, request):
	"""为这个客户端返回数据"""

	# 1. 接收浏览器发送过来的请求 ，即http请求  
	# GET / HTTP/1.1
	# .....
	# request = new_socket.recv(1024).decode("utf-8")
	# print(">>>"*50)
	# print(request)

	request_lines = request.splitlines()
	print("")
	print(">"*20)
	print(request_lines)

	# GET /index.html HTTP/1.1
	# get post put del
	file_name = ""
	ret = re.match(r"[^/]+(/[^ ]*)", request_lines[0])
	if ret:
		file_name = ret.group(1)
		# print("*"*50, file_name)
		if file_name == "/":
			file_name = "/index.html"

	# 2. 返回http格式的数据，给浏览器
	
	try:
		f = open("./html" + file_name, "rb")
	except:
		response = "HTTP/1.1 404 NOT FOUND\r\n"
		response += "\r\n"
		response += "------file not found-----"
		new_socket.send(response.encode("utf-8"))
	else:
		html_content = f.read()
		f.close()

		response_body = html_content                               

		response_header = "HTTP/1.1 200 OK\r\n"
		response_header += "Content-Length:%d\r\n" % len(response_body)
		response_header += "\r\n"

		response = response_header.encode("utf-8") + response_body
		new_socket.send(response)

def main():
	"""用来完成整体的控制"""
	# 1. 创建套接字
	tcp_server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
	tcp_server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)

	# 2. 绑定
	tcp_server_socket.bind(("", 7890))

	# 3. 变为监听套接字
	tcp_server_socket.listen(128)
	tcp_server_socket.setblocking(False)  # 将套接字变为非堵塞

	client_socket_list = list()
	while True:
		# 4. 等待新客户端的链接
		try:
			new_socket, client_addr = tcp_server_socket.accept()
		except Exception as ret:
			pass
		else:
			new_socket.setblocking(False)
			client_socket_list.append(new_socket)


		for client_socket in client_socket_list:
			try:
				recv_data = client_socket.recv(1024).decode("utf-8")
			except Exception as ret:
				pass
			else:
				if recv_data:
					service_client(client_socket, recv_data)
				else:
					client_socket.close()
					client_socket_list.remove(client_socket)

	# 关闭监听套接字
	tcp_server_socket.close()

if __name__ == "__main__":
	main()

# 这段代码最核心的部分仅仅是第45行，使用长连接时head需要添加body的长度，让浏览器判断数据是否接受完
# 如果接收的body的长度等于head中指定的len(response_body), 那么无需服务器调用close, 浏览器也会显示
# 页面. 之后浏览器再发送请求，服务器再给予相应，循环往复，一直到客户端调用close服务器才关闭套接字.
```

 

**epoll** 

**gevent的底层就是用的epoll  但epoll的效率是之前的geven http服务器无法比拟的**

**epoll的核心是共享内存(内存映射空间)和事件通知(不遍历)**

**linus只是写了linux内核：kernel, 但是此内核是linux最核心的部分，通常用的redhat ubantu等是在内核基础上加以包装**    

**计算机的内存可以分为 操作系统的内存空间 程序运行的内存空间 前者不会让程序访问**

   ==12'50''== **的图可以看一下**

**用作服务器的主机基本都是linux或unix，主要是linux，因为其中有epoll, 在网络方面很有优势**  



案例：

```python
import socket
import re
import select


def service_client(new_socket, request):
    """为这个客户端返回数据"""

    # 1. 接收浏览器发送过来的请求 ，即http请求  
    # GET / HTTP/1.1
    # .....
    # request = new_socket.recv(1024).decode("utf-8")
    # print(">>>"*50)
    # print(request)

    request_lines = request.splitlines()
    print("")
    print(">"*20)
    print(request_lines)

    # GET /index.html HTTP/1.1
    # get post put del
    file_name = ""
    ret = re.match(r"[^/]+(/[^ ]*)", request_lines[0])
    if ret:
        file_name = ret.group(1)
        # print("*"*50, file_name)
        if file_name == "/":
            file_name = "/index.html"

    # 2. 返回http格式的数据，给浏览器
    
    try:
        f = open("./html" + file_name, "rb")
    except:
        response = "HTTP/1.1 404 NOT FOUND\r\n"
        response += "\r\n"
        response += "------file not found-----"
        new_socket.send(response.encode("utf-8"))
    else:
        html_content = f.read()
        f.close()

        response_body = html_content

        response_header = "HTTP/1.1 200 OK\r\n"
        response_header += "Content-Length:%d\r\n" % len(response_body)
        response_header += "\r\n"

        response = response_header.encode("utf-8") + response_body

        new_socket.send(response)


def main():
    """用来完成整体的控制"""
    # 1. 创建套接字
    tcp_server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    tcp_server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)

    # 2. 绑定
    tcp_server_socket.bind(("", 7890))

    # 3. 变为监听套接字
    tcp_server_socket.listen(128)
    tcp_server_socket.setblocking(False)  # 将套接字变为非堵塞

    # 创建一个epoll对象(开辟了操作系统和程序共用空间)
    epl = select.epoll()

    # 将监听套接字对应的fd注册到epoll中   .file是获取文件底层描述符
    epl.register(tcp_server_socket.fileno(), select.EPOLLIN)

    fd_event_dict = dict()

    while True:

        fd_event_list = epl.poll()  # 默认会堵塞，直到 os监测到数据到来 通过事件通知方式 告诉这个程序，此时才会解堵塞

        # [(fd, event), (套接字对应的文件描述符, 这个文件描述符到底是什么事件 例如 可以调用recv接收等)]
        for fd, event in fd_event_list:
            # 等待新客户端的链接
            if fd == tcp_server_socket.fileno():
                new_socket, client_addr = tcp_server_socket.accept()
                epl.register(new_socket.fileno(), select.EPOLLIN)
                fd_event_dict[new_socket.fileno()] = new_socket
            elif event==select.EPOLLIN:
                # 判断已经链接的客户端是否有数据发送过来
                recv_data = fd_event_dict[fd].recv(1024).decode("utf-8")
                if recv_data:
                    service_client(fd_event_dict[fd], recv_data)
                else:
                    fd_event_dict[fd].close()
                    epl.unregister(fd)
                    del fd_event_dict[fd]


    # 关闭监听套接字
    tcp_server_socket.close()


if __name__ == "__main__":
    main()


```



> 这里几乎所有的代码都没有实用价值（除了epoll有意义一些），了解一下核心的思想即可.

[^ 1]: web服务器01大节+03大节中04 05小节 + 04大节