##                                         web服务器



## 01-正则表达式



==正则表达式的核心部分是通用的，只是在不同语言中的相应函数名可能不同==



**匹配单个字符**

```python
.    # 匹配任意一个字符   (唯独无法匹配\n，即无法匹配换行符）
[]   # 匹配[]中列举的字符
\d   # 匹配数字,即0-9
\D   # 匹配非数字，即不是数字
\s   # 匹配空白，即空格和tab键
\S   # 匹配非空白
\w   # 匹配单词字符，即a-z,A-Z,0-9，_   以及各种语言如汉字  范围很广
\W   # 匹配非单词字符



re.match(r"[12345678]",...)
# 这里可以匹配1-8之间的任意一个数字
re.match(r"[1-8]",...)
# 匹配1-8之间任意一个数字
re.match(r"[1-36-8]",...)
# 匹配1-3，6-8之间任意一个数字(1,2,3,6,7,8)
re.match(r"[A-Za-z1-5]"...) 
# 注意  ：这里A-Z只能匹配大写，a-z是小写       而 \w既可以匹配大写也可以匹配小写
re.match(r".*", "\n").group()
#  此时不匹配，上面已经提到过了，"."无法匹配\n   
re.match(r".*", "\n", re.S).group()
#  加上re.S这个参数就可以真正匹配到任意一个字符.

```



**匹配多个字符** 

```python
*  # 匹配前一个字符出现0次或者无限次，即可有可无
+  # 匹配前一个字符出现1次或者无限次，即至少有一次
？ # 匹配前一个字符出现0次或者1次    
{m} # 匹配前一个字符出现m次
{m,n} # 匹配前一个字符出现从m到n次

 
 re.match(r"速度与激情\d{3}", "速度与激情1").group()
# \d(数字)需要出现三次并且只能出现三次
 re.match(r"速度与激情\d{1,3}", "速度与激情12").group()
# \d(数字)可以出现1-3次，即1次、2次、3次
re.match(r"021-?\d{8}", "02112345678").group()
re.match(r"021-?\d{8}", "021-12345678").group()
# 显然二者都可以匹配，"-"可以有1个或者0个

```



**匹配开头和结尾**

```python
^  # 匹配字符串开头     (match默认从开头开始匹配)
$  # 匹配字符串结尾     
```



demo（判断字符串是否符合命名规范）：

```python
import re


def main():
	names = ["age", "_age", "1age", "age1", "a_age", "age_1_", "age!", "a#123", "__________"]
	for name in names:
		ret = re.match(r"^[a-zA-Z_][a-zA-Z0-9_]*$", name)   # [1]
		if ret:
			print("变量名:%s 符合要求....通过正则匹配出来的数据是:%s" % (name, ret.group()))
		else:
			print("变量名:%s 不符合要求...." % name)


if __name__ == "__main__":
	main()
    
# [1]处不能写r"^[a-zA-Z_][\w]*$",因为\w范围过广.
# if ret:  ...   else这种写法很简便，了解一下. 若正则匹配，则返回一个对象，if obj会返回True.
```

- 若在正则表达式中仅仅遇到了一些普通的字符，比如 .  比如 ? 等，仅仅需要在它们前面添加一个反斜杠进行转义(e.g. `re.match(r"[a-zA-Z_0-9]{4,20}\.com$")`,这里需要在.之前加\\)



- 分组

```python
| # 匹配左右任意一个表达式，相当于or
(ab) # 将括号中字符作为一个分组
\num # 引用分组num匹配到的字符串
(?P<name>)  # 分组起别名       了解一下即可
(?P=name)  # 分组起别名为name分组匹配到的字符串   了解一下即可
```

```python
re.match(r"[a-zA-Z_0-9]{4,20}@(163|126)\.com$", email)
#  "|"的作用范围会自动到括号，即163或者126二选一

re.match(r"<(\w*)>.*</\1>",...) 
#  这里的\1是指此处需要和group(1)的内容完全相同  
#  注意\1处没括号
```

- re.search()和match的区别就是它不会从头匹配，但是也仍然只匹配一个，匹配所有满足条件的组分需要写re.findall(), 它将结果以列表的形式返回：`re.findall(r"\d+","python = 9999, c = 7898, c++ = 1234")` 

​       返回`["9999","7898","1234"]` 

- sub自行百度，略.